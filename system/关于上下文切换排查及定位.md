# CPU上下文切换 

---

## CPU上下文切换是什么意思？
Linux在同时运行多任务时，是通过轮流分配CPU的方式造成多任务同时运行的错觉。并通过`CPU寄存器` 和 `程序计数器`来记录任务从哪里加载、又从哪里运行。**CPU寄存器** 是CPU中内置的容量小，但速度极快的内存。而**程序计数器** 则是记录CPU正在执行的指令或者即将执行的下一条指令。他们是CPU执行任务前必须依赖的环境，因此称为 `CPU上下文`。

**进程与线程的区别**
> * 1.进程是资源分配和执行的基本单位。  
> * 2.线程是任务调度和运行的基本单位。
> * 3.线程没有资源，进程给线程提供虚拟内存、栈、全局变量等共享资源，而线程可以共享进程的资源。

进程从用户态到内核态的转变，需要通过系统调用来完成。系统调用的过程中，并不会涉及到虚拟内存等进程用户态的资源，也不会进程切换。需要注意的是系统调用过程通常称为特权模式切换，而不是上下文切换。但实际上，系统调用过程中，CPU 的上下文切换还是无法避免的。

**CPU上下文切换** 就是将上一个CPU上下文保存到系统内核中，并在任务重新运行时加载进来。进程从用户态到内核态的转变，需要通过系统调用来完成。

**什么情况下会触发上下文切换？**  
系统调用、进程状态转换(运行、就绪、阻塞)、时间片耗尽、系统资源不足、sleep、优先级调度、硬件中断等。

根据任务的不同，CPU 的上下文切换又分为 `进程上下文切换`、`线程上下文切换` 和 `中断上下文切换`。
> * **进程上下文切换**，指的是一个进程切换到另一个进程。**系统调用** 的过程只有一个进程运行，但是一次系统调用的过程将发生两次CPU上下文切换。
> * **线程上下文切换**，一般分为2种情况，前后线程属于同一进程，另一个情况是前后两个进程不属于同一个进程。当前者的情况出现时，只需切换不同享的数据即可；后而后者因为资源不共享，因此和进程切换相似。  
   * * 1. 当进程只有一个线程时，进程等于线程；
   * * 2. 当进程拥有多个线程时，将共享同一虚拟内存、栈以及全局变量等资源。该资源在发生上下文切换时是不需要保存；
   * * 3. 线程也拥有自己的私有数据，比如栈和寄存器等。当发生上下文切换时，是需要保存的；
> * **中断上下文切换**，快速响应硬件的事件，中断处理会打断进程的正常调度和执行。同一CPU内，硬件中断优先级高于进程。切换过程类似于系统调用的时候，不涉及到用户运行态资源。但大量的中断上下文切换同样可能引发性能问题。

**有哪些减少上下文切换的技术用例？**  
数据库连接池（复用连接）、合理设置应用的最大进程，线程数、直接内存访问DMA、零拷贝技术等。

**查看上下文切换**  
vmstat 是一个常用的系统性能分析工具，主要用来分析系统的内存使用情况，也常用来分析 CPU 上下文切换和中断的次数。
```
$ vmstat 5
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id  wa st
 0  0      0 7005360  91564 818900  0    0     0     0    25   33 0   0 100  0  0
```
**提示：**  
　　r（Running or Runnable）: 就绪队列的长度，也就是正在运行和等待 CPU 的进程数；  
　　b（Blocked）: 处于不可中断睡眠状态的进程数；  
　　swpd: 虚拟内存已使用的大小，如果大于0，表示你的机器物理内存不足了，如果不是程序内存泄露的原因，那么你该升级内存了或者把耗内存的任务迁移到其他机器；  
　　si: 每秒从磁盘读入虚拟内存的大小，如果这个值大于0，表示物理内存不够用或者内存泄露了，要查找耗内存进程解决掉。我的机器内存充裕，一切正常。  
　　so: 每秒虚拟内存写入磁盘的大小，如果这个值大于0，同上；  
　　bi: 块设备每秒接收的块数量，这里的块设备是指系统上所有的磁盘和其他块设备，默认块大小是1024byte，我本机上没什么IO操作，所以一直是0，但是我曾在处理拷贝大量数据(2-3T)的机器上看过可以达到140000/s，磁盘写入速度差不多140M每秒；  
　　bo: 块设备每秒发送的块数量，例如我们读取文件，bo就要大于0。bi和bo一般都要接近0，不然就是IO过于频繁，需要调整；  
　　in（interrupt）: 则是每秒中断的次数；  
　　cs（context switch）: 每秒上下文切换的次数；  
　　st: cpu在虚拟化环境上在其他租户上的开销;  
　　
**vmstat 只给出了系统总体的上下文切换情况，要想查看每个进程的上线文切换次数，需要通过`pidstat -wt 5 `命令（pidstat是进程分析工具）。**
```
# 每隔 5 秒输出 1 组数据
$ pidstat -w 5
pidstat -wt 5
Linux 4.4.0-1065-aws (ip-172-31-25-95) 	02/16/19 	_x86_64_	(1 CPU)

13:22:22      UID      TGID       TID   cswch/s nvcswch/s  Command
13:22:27        0         3         -      0.60      0.00  ksoftirqd/0
13:22:27        0         -         3      0.60      0.00  |__ksoftirqd/0
13:22:27        0         7         -      2.00      0.00  rcu_sched
13:22:27        0         -         7      2.00      0.00  |__rcu_sched
```
**提示**：  
　　cswch：表示每秒自愿上下文切换（voluntary context switches）的次数。是指无法获取所需资源（比如，内存、I/O等资源），导致的上下文切换。  
　　nvcswch：表示每秒非自愿上下文切换（non voluntary context switches）的次数。指进程由于时间片已到等原因，被系统强制调度而发生的上下文切换。比如大量进程争抢CPU资源。  

**获取中断类型**
```
 $ watch -d cat /proc/interrupts
  48:  836243176  xen-percpu-virq      timer0
 49:          0  xen-percpu-ipi       resched0
 50:          0  xen-percpu-ipi       callfunc0
 51:          0  xen-percpu-virq      debug0
 52:          0  xen-percpu-ipi       callfuncsingle0
 53:          0  xen-percpu-ipi       spinlock0
 54:        212   xen-dyn-event     xenbus
 55:    2456228   xen-dyn-event     blkif
 56:    8606407   xen-dyn-event     eth0
NMI:          0   Non-maskable interrupts
LOC:          0   Local timer interrupts
SPU:          0   Spurious interrupts
PMI:          0   Performance monitoring interrupts
IWI:         22   IRQ work interrupts
RTR:          0   APIC ICR read retries
RES:          0   Rescheduling interrupts
CAL:          0   Function call interrupts
TLB:          0   TLB shootdowns
TRM:          0   Thermal event interrupts
THR:          0   Threshold APIC interrupts
DFR:          0   Deferred Error APIC interrupts
MCE:          0   Machine check exceptions
MCP:      43633   Machine check polls
HYP:  847092680   Hypervisor callback interrupts
```
**查看每个CPU统计信息**  
多处理器统计信息工具，能够报告每个CPU的统计信息。
```
mpstat -P ALL 1
Linux 2.6.32-573.el6.x86_64 (zbredis-30104)     09/14/2017  _x86_64_    (12 CPU)
 
03:14:03 PM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest   %idle
03:14:04 PM  all    0.00    0.00    0.08    0.00    0.00    0.00    0.00    0.00   99.92
03:14:04 PM    0    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
03:14:04 PM    1    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
03:14:04 PM    2    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
03:14:04 PM    3    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
03:14:04 PM    4    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
03:14:04 PM    5    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
03:14:04 PM    6    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
03:14:04 PM    7    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
03:14:04 PM    8    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
03:14:04 PM    9    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
03:14:04 PM   10    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
03:14:04 PM   11    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
```
**提示：**  
　　irq: 硬件中断CPU用量；  
　　sofr: 软件中断CPU用量；  
　　steal: 耗费在服务其他租户的时间；  
　　guest: 花在访客虚拟机的时间；  

重要关注列有 %user/%sys/%idle 。显示了每个CPU的用量以及用户态和内核态的时间比例。可以根据这些值查看那些跑到100%使用率（%user + %sys）的CPU，而其他CPU并未跑满可能是由单线程应用程序的负载或者设备中断映射造成。
